<!--
 * @Author: ailiang
 * @Date: 2020-11-30 09:15:32
 * @LastEditors: ailiang
 * @LastEditTime: 2020-12-06 20:59:47
-->
学习笔记

1.{}定义块级作用域，再该作用域内定义的变量只能再该作用域内使用（不用为同一含义的变量另取名字了）

2.AI思路：
1）定义一个willwin函数，判断是否有一步棋下了之后可以达到胜利条件（只判断最后一步，相对容易，可以想到）
2）反向倒推：
A.有一步棋下了之后，对方会willwin(输)
B.有一步棋下了之后，对方遇到情况A（即我方获胜）
C.有一步棋下了之后，对方不会出现情况A(和)
每一步棋都会递归的判断以上三种情况，直至最后
bestChoice:
首先定义三种状态 result： -1（输） 0（和） 1 （赢）
定义起始的result为 -2
根据递归判断每一步棋的结果，取最好的结果（比当前结果好的结果）
根据willwin判断，对方willwin则为-1，我方willwin则为1，双方都没有willwin则为0

局限性：
bestChoice会计算每一步棋的所有可能性，计算次数过多，对于3x3嗨行
对于五子棋（12x12）则由于计算次数过多会导致浏览器崩溃，需要寻找优化方法
优化方法思考：
对于五子棋（12x12）或以上
1.从棋盘中心开始向外搜索，只要搜索到获胜条件即可停止
2.将搜索范围缩小至对方所下棋子（或己方已存在棋子）的四周5x5内，间隔太远的棋子意义不大（准确？）

3.bestChioce启发
将复杂的问题化为一个个简单的问题：
遇到ai问题时，首先想到的便是从第一步开始要如何计算（没有头绪）❌
反向思考：判断是否有一步棋下了之后满足获胜条件（只需遍历当前棋盘的空位，判断当前位置下了之后是否会满足获胜条件）
反向递归判断即可获得第一步的bestchoice
